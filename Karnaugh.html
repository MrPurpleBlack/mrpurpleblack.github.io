<html>
    <head>
        <title>Построение логических выражений</title>
        <meta content="text/html; charset=utf-16" />
        <link rel="stylesheet" type="text/css" href="styles.css"/>
        <header align="center"></header>
    </head>
    <body>
        <div id="interface">
            <div id="input">
                <fieldset>
                    <legend>Ввод данных</legend>
                    <form name="DataInput">
						<div id="TT">
							<span id="Vars">X<sub>0</sub>X<sub>1</sub>X<sub>2</sub>X<sub>3</sub></span>
						<div>
						</div>
							<textarea type="text" name="TruthTable" id="TruthTable" readonly="true">0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 1 0 0 1 1 0 1 0 1 0 1 1 1 1 0 0 1 1 0 1 1 1 1 0 1 1 1 1</textarea>
                        </div>
						<textarea type="text" name="exp" id="exp" maxLength="16" onKeyUp="if(/[^0-1 .]/i.test(this.value)){this.value=this.value.substr(0,this.value.length-1);}"></textarea>
                        <div class="data">
                            <b>Количество переменных</b><br>
                            <select name="NumOfVars" onchange="ValNumChange(document.DataInput.NumOfVars.value); ReloadKC();">
                                <option value="1" > 1 переменная </option> 
                                <option value="2" > 2 переменные </option>
                                <option value="3" > 3 переменные </option> 
                                <option value="4" selected> 4 переменные </option> 
                                <option value="5" > 5 переменные </option>
                                <option value="6" > 6 переменные </option>
                            </select>
                            <p>
                            <b>Метод минимизации</b><br>
                            <input name="MM" type="radio" value="1" checked>
                            МДНФ<br>
                            <input name="MM" type="radio" value="0">
                            МКНФ 
                            </p>
                            <input type="button" value="Вычислить" onclick="ReloadValues(); GROUPS = calculate(); list_of_groups = MakeLogExpression(GROUPS); Group(GROUPS); document.OutputData.ret.value = list_of_groups.join(out_br);"> 
                        </div>
                    </form>    
                </fieldset>        
            </div>
            
            <div id="karnaugh">
                <fieldset>
                    <legend>Карта Карно</legend>
					<div id="container"></div>
					<form name="KarnaughSets">
						<div id = "KarnaughSetings">
							Прозрачность полукарт
							<input type="range" name="PlaneOpacity" min="0" max="1" step="0.01" value="0.7" onChange="ChangePLanes(document.KarnaughSets.PlaneOpacity.value);">
							<div id="group" ></div>
						</div>
						
					</form>
				</fieldset>
            </div>
            
            <div id="output">    
                <fieldset>
                    <legend>Вывод</legend>
                    <form name="OutputData">
                        <textarea id="ret" readonly="true"></textarea>
						
                    </form> 
                </fieldset>
            </div>
        </div>
		<div id="author"><h4>Составитель логических выражений © 2015</h4></div> 
		
        <script src="Karnaugh.js"></script>
		<script src="three/three.min.js"></script>
		<script src="three/Projector.js"></script>
		
		<script src="three/TextGeometry.js"></script>
		<script src="three/FontUtils.js"></script>
		<script src="three/gentilis_regular.typeface.js"></script>
		<script>
			var container;
			var expression;

			var camera, scene, renderer;
			var cube, plane;

			var targetRotationX = 0;
			var targetRotationOnMouseDownX = 0;
			
			var targetRotationY = 0;
			var targetRotationOnMouseDownY = 0;
			
			var mouseX = 0;
			var mouseXOnMouseDown = 0;
			
			var mouseY = 0;
			var mouseYOnMouseDown = 0;
			
			var windowHalfX = 100;
			var windowHalfY = 100;
			
			var NumOfVars = document.DataInput.NumOfVars.value;
			var BinPow = Math.pow(2,NumOfVars);
			var size = 20;
			var gap = 4;
			var gap_plus_size = size + gap;
			
			var PlaneOpacity = 0.7;
			var GROUPS = [];
			var list_of_groups = [];

			var groupCubes = new THREE.Group();
			var groupPlanes = new THREE.Group();

			//var colors = [[2,0,0], [0,2,0], [0,0,2], [2,2,0], [0,2,2], [2,0,2], [2,1,0], [1,0,2], [1,2,0], [0,1,2]/*, [2,0,1], [1,0,0], [0,1,0], [0,0,1], [1,1,0], [0,1,1], */[1,0,1], [1,0.5,0], [0,1,0.5], [0.5,0,1], [0.5,0.5,0], [0,0.5,0.5], [0.5,0,0.5]];
			
			var colors = [[0.25,0,0.5],[1,0,0.5],[0,0,0.625],[0,0.5,0.75],[0,1,1],[0,1,0.25],[0,0.25,0],[0.5,0,0.25],[0.5,0.5,0],[0.25,0,0],[0,0.25,0.25],[1,0,0],[1,1,0],[1,0.5,0],[0.25,0.25,0.25],[0.25,0,0.25]]
			
			//var cur_year = 1970+Math.floor(new Date().getTime()/(1000*60*60*24*365));
			//alert("Год:" + cur_year);
			
			init();
			animate();
			
			//Инициализация рабочей области
			function init()
			{
				//Инициализация контейнера
				container = document.getElementById('container');
				
				//Камера
				camera = new THREE.PerspectiveCamera( 70, 1, 1, 1000 );
				camera.position.z = 100 + 20*(NumOfVars);
				
				//Создание сцены
				scene = new THREE.Scene();
							
				//Вычисление разположения и размеров объектов сцены
				var MaxCount = [1,1,1];
				var MaxCountPx = [1,1,1];
				
				for(var i = 0; i < NumOfVars; i++)
					MaxCountPx[i%3] *= 2;
				
				for(i = 2; i + 1; i--)
					MaxCount[i] = (MaxCountPx[i] - 1)*(gap_plus_size)/2;
									
				var buf = MaxCountPx.shift();
				MaxCountPx.push(buf);
				
				//Создание полукарт
				Plane(MaxCount,MaxCountPx);
				
				//Создание ячеек
				Cube(MaxCount)
								
				//Вывод созданных элементов на сцену
				scene.add(groupCubes);
				scene.add(groupPlanes);
				
				//Создание рендерера
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(0xffffff);
				renderer.setSize(400, 400);
				container.appendChild(renderer.domElement);
			
				//События мыши для вращения КК
				container.addEventListener('mousedown', onDocumentMouseDown, false);
				container.addEventListener('touchstart', onDocumentTouchStart, false);
				container.addEventListener('touchmove', onDocumentTouchMove, false);
				
				//Событие изменения размера окна
				window.addEventListener('resize', onWindowResize, false);
				console.log(scene)
			}
			
			//Визуализация групп ячеек
			function Group(groups)//3 4 5 6
			{
				console.log(list_of_groups)
				for(var group = 0; group < groups.length; group++)
				{
					for(var cell = 0; cell < groups[group].length; cell++)
					{
						groupCubes.children[groups[group][cell]].material.color.r = (groupCubes.children[groups[group][cell]].material.color.r + 2*colors[group%16][0])/2;
						groupCubes.children[groups[group][cell]].material.color.g = (groupCubes.children[groups[group][cell]].material.color.g + 2*colors[group%16][1])/2;
						groupCubes.children[groups[group][cell]].material.color.b = (groupCubes.children[groups[group][cell]].material.color.b + 2*colors[group%16][2])/2;						
					}
					document.getElementById('group').innerHTML += '<p><input type="checkbox" name="group' + group + '" value="' + group + '" onchange="onGroupChange(document.KarnaughSets.group' + group + ')" checked>' + list_of_groups[group] + '</p>';
				}
			}
			
			function onGroupChange(group)
			{
				for(var cell = 0; cell < GROUPS[group.value].length; cell++) 
				{
					if(group.checked)
					{
						groupCubes.children[GROUPS[group.value][cell]].material.color.r = (groupCubes.children[GROUPS[group.value][cell]].material.color.r + 2*colors[group.value%16][0])/2;
						groupCubes.children[GROUPS[group.value][cell]].material.color.g = (groupCubes.children[GROUPS[group.value][cell]].material.color.g + 2*colors[group.value%16][1])/2;
						groupCubes.children[GROUPS[group.value][cell]].material.color.b = (groupCubes.children[GROUPS[group.value][cell]].material.color.b + 2*colors[group.value%16][2])/2;
					}
					else
					{
						groupCubes.children[GROUPS[group.value][cell]].material.color.r = (groupCubes.children[GROUPS[group.value][cell]].material.color.r*2 - 2*colors[group.value%16][0]);
						groupCubes.children[GROUPS[group.value][cell]].material.color.g = (groupCubes.children[GROUPS[group.value][cell]].material.color.g*2 - 2*colors[group.value%16][1]);
						groupCubes.children[GROUPS[group.value][cell]].material.color.b = (groupCubes.children[GROUPS[group.value][cell]].material.color.b*2 - 2*colors[group.value%16][2]);
					}
				}
			}
			
			//Изменение яркости полукарт
			function ChangePLanes(NewOpacity)
			{
				for(var child = 0; child < groupPlanes.children.length; child++)
					groupPlanes.children[child].material.opacity = NewOpacity;  
			}
			
			//Переинициализация
			function ReloadKC()
			{
				NumOfVars = document.DataInput.NumOfVars.value;
				BinPow = Math.pow(2,NumOfVars);
				PlaneOpacity = document.KarnaughSets.PlaneOpacity.value;
				
				groupCubes = new THREE.Group();
				groupPlanes = new THREE.Group();
				container.removeChild(renderer.domElement);
				document.getElementById('group').innerHTML = '';
				init();
				animate();
			}
			
			//Перезагрузка значений
			function ReloadValues()
			{
				NumOfVars = document.DataInput.NumOfVars.value;
				BinPow = Math.pow(2,NumOfVars);
				expression = document.DataInput.exp.value;
				var pos = [0,0,0];
				var TextMaterial = new THREE.MeshBasicMaterial({color: 0x000000, overdraw: 0.5});
				groupCubes.children = groupCubes.children.slice(0,BinPow); 
				
				for(var child = 0; child < BinPow; child++)
				{
					groupCubes.children[child].material.color.r = 0.75;
					groupCubes.children[child].material.color.g = 0.75;
					groupCubes.children[child].material.color.b = 0.75;
					
					pos[0] = groupCubes.children[child].position.x - 5;
					pos[1] = groupCubes.children[child].position.y - 6;
					pos[2] = groupCubes.children[child].position.z - 1;					
					
					//Создание текста
					var text3d = new THREE.TextGeometry(expression[child],{size: 15, height: 2, font: "gentilis", curveSegments: 1});
					text = new THREE.Mesh(text3d, TextMaterial);
					text.position.set(pos[0], pos[1], pos[2]);
					groupCubes.add(text);
				}
				scene.add(groupCubes);
				document.getElementById('group').innerHTML = '';
			}
			
			//Создание ячеек
			function Cube(MaxCount)
			{
				var pos = [0,0,0];
				var StartCount = [0,0,0];
				var end;
				
				BinPow > 8 ? end = 8 : end = BinPow;
						
				for(var shift = 0; shift < Math.ceil(BinPow/8); shift++)
				{
					if(shift == 0)
						for(var coor = 0; coor < 3; coor++)
						{
							StartCount[coor] = -MaxCount[coor];
							MaxCount[coor] -= (NumOfVars > 3+coor)*2*gap_plus_size;
						}
					
					for(var j = 1; j <=8 ;j *=2)
						if(shift%(2*j) == j)
							for(var coor = 0; Math.pow(2,coor) <= j;coor ++)
							{
								StartCount[coor] = -StartCount[coor];
								MaxCount[coor] = -MaxCount[coor];
							}
						
					
					for(var coor = 0; coor < 3; coor++)
							pos[coor] = StartCount[coor];

					//for(var j = 0; j <= (NumOfVars-1)%3; j++)
					pos[(NumOfVars-1)%3] -= Math.pow(-1,(shift%2))*gap_plus_size;
					
					//Костыли
					pos[0] += Math.pow(-1,!(shift%2))*gap_plus_size*(NumOfVars == 5)*(shift == 1 || shift == 2);
					pos[1] += Math.pow(-1,(shift%3))*gap_plus_size*(NumOfVars == 6)*(shift == 1 || shift == 3 || shift == 4 || shift == 6);
					
					for(var i = 0; i < end; i++)
					{
						var count = (NumOfVars-1)%3;
						while(pos[count] == MaxCount[count])
						{
							pos[count] = StartCount[count--];
							if(count < 0)
								count = 2;
						}
						
						var geometry = new THREE.BoxGeometry(size, size, size);
						var material = new THREE.MeshBasicMaterial({color: 0xcccccc/*map: THREE.ImageUtils.loadTexture('cell_texture.jpg')*/, opacity: 0.7,transparent: true, overdraw:0.5});
						pos[count] += Math.pow(-1,!(shift%Math.pow(2,count+1)<Math.pow(2,count)))*gap_plus_size;// count == 0; shift: 0 1 2 3 4 5 6 7; count == 1; shift: 0 1 2 3 4 5 6 7; count == 2; shift 0 1 2 3 4 5 6 7
						cube = new THREE.Mesh(geometry, material);//							  	 							 	  + - + - + - + -				      + + - - + + - - 				     + + + + - - - -
						cube.position.set(pos[0], pos[1], pos[2]);
						groupCubes.add(cube);
					}
				}
			}
			
			//Создание плоскостей
			function Plane(MaxCount,MaxCountPx)
			{
				var text_pos = [];
				var TextMaterial = new THREE.MeshBasicMaterial({color: 0x000000, overdraw: 0.5, opacity: PlaneOpacity, transparent: true});
				var material = new THREE.MeshBasicMaterial({color: 0x757575, overdraw: 0.5, opacity: PlaneOpacity, transparent: true});
				var max = 2;
				//Вычисление расположения и размеров полукарт
				for(i = 0; i < NumOfVars; i++)
				{
					var not = 'n';
					var count = 2;
					var plane_size = [size + (MaxCountPx[i%3] - 1)*gap_plus_size,size + gap_plus_size*Math.floor(NumOfVars/(4 + i))];
					if(i < 3)
					{
						var num = -1;
						var plane_pos = [(gap_plus_size/2)*Math.ceil(NumOfVars/(3 + i)),0,- 30 - MaxCount[count]];
					}
					else
					{
						max = 3;
						var num = 1;
						var plane_pos = [gap_plus_size + size/2,0,30 + MaxCount[5-i]];
					}
					
					for(var iter = 0; iter < i%3; iter++)
					{
						var buf = plane_pos.pop();
						plane_pos.unshift(buf);
						count++;
						if(count > 2)
							count = 0;
					}
							
					plane_pos[count] = num*(30 + MaxCount[count]);
					
					for(var sign = 0; sign < max; sign ++)
					{
						plane_pos[i%3] *= -1;
						if(sign == 2)
						{
							not = '';
							plane_pos[i%3] = 0;
							plane_size[1] += gap_plus_size;
						}
						
						//Создание полукарты
						var geometry = new THREE.PlaneBufferGeometry(plane_size[0], plane_size[1]);
						angle_set = [0,0,0];
						angle_set[(5 - i)%3] = -Math.PI/2;
						plane = new THREE.Mesh(geometry, material);
						plane.material.side = THREE.DoubleSide;
						plane.rotation.set(angle_set[0], angle_set[1], angle_set[2])
						plane.position.set(plane_pos[0], plane_pos[1], plane_pos[2]);
						groupPlanes.add(plane);
						
						//Создание текста
						text_pos[0] = plane_pos[0]
						text_pos[1] = plane_pos[1]
						text_pos[2] = plane_pos[2]
						
						if(count != 0)
							text_pos[count-1] = MaxCount[count-1] + 20
						else
							text_pos[2] = MaxCount[2] + 20
							
						if((i<3)&&(sign == 1))
							not = '';
						
						var text3d = new THREE.TextGeometry(not + 'X' + i,{size: 5, height: 0.5, font: "gentilis", curveSegments: 1});
						text = new THREE.Mesh(text3d, TextMaterial);
						text.rotation.set(angle_set[0], angle_set[1], 0);
						text.position.set(text_pos[0], text_pos[1], text_pos[2]);
						groupPlanes.add(text);
				
					}
				}
			}
 
			function onWindowResize()
			{
				windowHalfX = 200;
				windowHalfY = 200;
				camera.aspect = 1;
				camera.updateProjectionMatrix();
				renderer.setSize(350, 350);
			}
 
			function onDocumentMouseDown(event)
			{
				event.preventDefault();
				container.addEventListener('mousemove', onDocumentMouseMove, false);
				container.addEventListener('mouseup', onDocumentMouseUp, false);
				container.addEventListener('mouseout', onDocumentMouseOut, false);
				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDownX = targetRotationX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationOnMouseDownY = targetRotationY;
			}
 
			function onDocumentMouseMove(event)
			{
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
				targetRotationY = targetRotationOnMouseDownY + (mouseY - mouseYOnMouseDown) * 0.02;
				targetRotationX = targetRotationOnMouseDownX + (mouseX - mouseXOnMouseDown) * 0.02;
			}
 
			function onDocumentMouseUp(event)
			{
				container.removeEventListener('mousemove', onDocumentMouseMove, false);
				container.removeEventListener('mouseup', onDocumentMouseUp, false);
				container.removeEventListener('mouseout', onDocumentMouseOut, false);
			}
 
			function onDocumentMouseOut(event)
			{
				container.removeEventListener('mousemove', onDocumentMouseMove, false);
				container.removeEventListener('mouseup', onDocumentMouseUp, false);
				container.removeEventListener('mouseout', onDocumentMouseOut, false);
			}
 
			function onDocumentTouchStart(event)
			{
				if (event.touches.length == 1)
				{
					event.preventDefault();
					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDownX = targetRotationX;
					mouseYOnMouseDown = event.touches[ 0 ].pageY - windowHalfY;
					targetRotationOnMouseDownY = targetRotationY;		 
				}
			}
 
			function onDocumentTouchMove(event)
			{
				if (event.touches.length == 1)
				{
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationX = targetRotationOnMouseDownX + (mouseX - mouseXOnMouseDown) * 0.05;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
					targetRotationY = targetRotationOnMouseDownY + (mouseY - mouseYOnMouseDown) * 0.05;
				}
			}
 
			function animate()
			{
				requestAnimationFrame(animate);
				render();
			}
 
			function render()
			{
				//horizontal rotation   
				groupCubes.rotation.y += (targetRotationX - groupCubes.rotation.y) * 0.1;
				groupPlanes.rotation.y += (targetRotationX - groupPlanes.rotation.y) * 0.1;
				//vertical rotation 
				groupCubes.rotation.x += (targetRotationY - groupCubes.rotation.x) * 0.05;
				groupPlanes.rotation.x += (targetRotationY - groupPlanes.rotation.x) * 0.05;
				renderer.render(scene, camera);
			}
		</script>
    </body>
</html>